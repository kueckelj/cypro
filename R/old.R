#' Title
#'
#' @description Helps to generate the rendered UIs with which to denote the 
#' x-, y-, etc. colums if the data has been generated by cell profiler.

example_selected <- function(lst, slot = "denoted_columns", col, nth, choices = NULL){
  
  if(base::is.character(lst[[slot]][[col]])){
    
    base::return(lst$denoted_columns[[col]])
    
  } else if(col != "additional") {
    
    base::return(base::colnames(lst$df)[nth])
    
  } else if(col == "additional"){
    
    additional_cols <- base::is.character(lst[[slot]][[col]])
    
    if(base::is.character(additional_cols) & base::length(additional_cols) >= 1){
      
      base::return(lst[[slot]][[col]])
      
    } else {
      
      base::return(choices)  
      
    }
    
  }
  
}


#' Title
#'
#' @description Take shiny input and update the condition and the condition_df variables
#' of the well plate data.frame.

update_condition <- function(var_condition, var_selected, input_condition){ #!!! not longer needed
  
  purrr::map2(.x = var_condition, 
              .y = var_selected, 
              .f = function(x, .selected){
                
                if(base::isTRUE(.selected)){
                  
                  if(base::length(input_condition) > 1){
                    
                    input_condition <- 
                      stringr::str_c(
                        base::seq_along(input_condition), 
                        input_condition, 
                        sep = "."
                      )
                    
                    res <- stringr::str_c(input_condition, collapse = " -> ")
                    
                  } else {
                    
                    res <- input_condition
                  }
                  
                } else {
                  
                  res <- x
                  
                }
                
                base::return(res)
                
              }) %>% 
    purrr::flatten_chr()
  
}

#' @rdname update_condition 
update_condition_df <- function(var_condition_df, var_selected, input_condition, input_phases){
  
  purrr::map2(.x = var_condition_df,
              .y = var_selected, 
              .f = function(df, .selected){
                
                phases <- base::colnames(df)
                
                if(base::isTRUE(.selected)){
                  
                  for(phase in base::seq_along(phases)){
                    
                    df[1, phase] <- input_condition[phase]
                    
                  }
                  
                } 
                
                base::return(df)
                
              })
  
}


#' Title
#' 
#' @description Make sure that all denoted columns appear only one time. 
#'
valid_example_cols <- function(example_list){ #!!! not longer needed?
  
  col_count <- 
    example_list$denoted_columns %>%
    purrr::flatten_chr() %>%
    base::table() %>%
    base::as.data.frame() %>% 
    purrr::set_names(nm = c("col", "count")) %>% 
    dplyr::filter(count > 1)
  
  if(base::nrow(col_count) >= 1){
    
    dupl_names <- glue::glue_collapse(col_count$col, sep = "', '", last = "' and '")
    
    ref1 <- confuns::adapt_reference(col_count$col, sg = "variable", pl = "variables")
    ref2 <- confuns::adapt_reference(col_count$col, sg = "is", pl = "are")
    
    msg <- glue::glue("Invalid variable denotation. The {ref1} '{dupl_names}' {ref2} used more than one time.")
    
    shiny_fdb(in_shiny = TRUE, ui = msg, type = "error", duration = 20)
    
    shiny::req(FALSE)
    
  }
  
}
