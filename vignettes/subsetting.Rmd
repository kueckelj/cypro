---
title: "Subset Data"
output: 
   html_document:
    df_print: paged
    toc: true
    toc_depth: 3
---

```{r folding, include = F}

hooks = knitr::knit_hooks$get()

hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}

knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)

```

```{r setup, include = F}

knitr::opts_chunk$set(echo = T, fold.output = T, fold.plot = F, message = F, fig.show  = "hold", out.width = "100%")

devtools::load_all()
library(tidyverse)
library(patchwork)

object_original <- readRDS(file = "data/bids-week4-big.RDS")

```

## 1. Introduction 

The amount of data generated by high throughput microscopy is immense. This can result in *cypro* objects containing hundreds of thousands of cells. Consider the example object below. 

```{r setup-vis, eval = F}

# load packages
library(cypro)
library(tidyverse)
library(patchwork)

object_original <- readRDS(file = "data/bids-week4-big.RDS")

object_original

```

```{r print-obj, eval = T, echo = F, fold.output = F}
object_original
```


Even 86000 cells are enough for certain machine learning algorithms to surrender. For instance, Rs partitioning around medoids  (PAM) implementation `cluster::pam()` does not work with more than 83.000 observations. Apart from computational efficiency you might want to focus on only subsets of cells, compute subcluster of a certain cluster etc. This is where you can make use of `cypros` subsetting functions: 

- `subsetByCellID()`
- `subsetByCellLine()`
- `subsetByGroup()`
- `subsetByCondition()`
- `subsetByFilter()`
- `subsetByGroup()`
- `subsetByNumber()`

They allow to conveniently split the data of your experiment into sub-*cypro* objects by a variety of aspects. On top of that the subsetting functions store the history of subsets in the sub-*cypro* objects. You can therefore always trace your analysis back to the original one. 

```{r no-subsetting, fold.output = F}

printSubsetHistory(object = object_original)

```

## 2. Subset by number 

Having computational efficiency in mind you can reduce the number of cells by randomly selecting cells while forcing equal numbers of cells across specific groups - such as cell line and condition. 

(If you are interested in analyzing proliferation and cell counts under certain conditions and treatments you should not use this function.)

```{r subset-by-number, fig.cap = "Figure 2.1 Adjustment of cell count as across was specified as 'condition'"}

# reduce the total number of cells to  ~ 50.000
object_reduced <-
  subsetByNumber(object_original,
                 new_name = "bids-w4-red",
                 across = "condition",
                 n_total = 50000)

# equal number of cells across conditions 
plotBarchart(object_original, variables = "condition", position = "stack") + 
  coord_flip() + 
  ggtitle("Original") +
  
plotBarchart(object_reduced, variables = "condition", position = "stack") + 
  coord_flip() + 
  ggtitle("Reduced")


```



## 3. Subset by groups and conditions 

You can create subsets according to all grouping variables your *cypro* object contains. (`subsetByCellLine()` and `subsetByCondition()` are wrapper around `subsetByGroup()`.)

```{r get-group-vars}

getGroupingVariableNames(object_reduced, verbose = F)

```

For instance, create subsets by wells if they share characteristics of interest.

```{r subset by wells }

# all wells 
getGroupNames(object_reduced, grouping_variable = "well")

# b wells
b_wells <- getGroupNames(object_reduced, grouping_variable = "well", starts_with("B"))

b_wells

object_bwells <-
  subsetByGroup(object_reduced,
                new_name = "bids-week4-red-bwells",
                grouping_variable = "well",
                groups = b_wells)

object_bwells

```

 
## 4. Subset by filter

Another option would be to create a subset in style of `dplyr::filter()` by filtering for cells that match certain requirements. 

```{r subset-by-filter, fig.cap = "Figure 4.1 Difference in distribution before and after subsetting."}

# remove obviuos outlier cells 
object_normal_cells <- 
  subsetByFilter(object_bwells, new_name = "normal-sized", AreaShape_Area < 20000 )

plotHistogram(object_bwells, variables = "AreaShape_Area") + 
  ggtitle("Before subsetting") + 
  
plotHistogram(object_normal_cells, variables = "AreaShape_Area") + 
  ggtitle("After subsetting")

```
The function `printSubsetHistory()` keeps track of the subsetting. 

```{r print, fold.output = F}

printSubsetHistory(object_normal_cells)

```


