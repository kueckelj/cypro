---
title: "Extract Data"
output: 
   html_document:
    df_print: paged
    toc: true
    toc_depth: 3
---

```{r folding, include = F}

hooks = knitr::knit_hooks$get()

hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}

knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)

```

```{r setup, include = F}

knitr::opts_chunk$set(echo = T, fold.output = F, fold.plot = F)

devtools::load_all()

object <- readRDS(file = "data/bids-week4.RDS")
object_tracks <- readRDS(file = "data/example-tracks.RDS")

#savecyproObject(object)

```

The framework in which `cypro` operates invites you to extract data from the *cypro* object to do your own analysis apart from what `cypro` currently offers. In order to do that you can make use of a variety of `get*()`-functions. 


```{r setup-vis, eval = F, echo = T}

# load packages
library(celltracer)

# load object from broad institute compound profiling experiment week 4
# contains one time imaging data
object <- readRDS(file = "data/bids-week4.RDS")

# load object that contains tracking data 
object_tracks <- readRDS(file = "data/example-tracks.RDS")

```


## 1. Cell data.frames

The data of your cells is stored in the `@cdata` slot in form of five data.frames. 

### 1.1 Stat(istic) data

The stats data.frame (statistics data.frame) contains summary information of every cell. In case of one time imaging it resembles exactly the data you have loaded in. In case of time lapse experiments it contains mean, median, maximum etc. summaries of all variables you specified to keep. Apart from the identifier variable *cell_id* all variables in this data.frame are numeric. 

```{r tracks-df}

stats_df <- getStatsDf(object = object)

# this data.frame can get pretty big 
dim(stats_df)

# select only the first 25 variables
select(stats_df, 1:25) %>% 
  # print only the first 100 rows 
  head(100)

```

This data.frame serves as the basic for most of the statistical tests, dimensional reduction and machine learning techniques you can use with `cypro`. See the [tutorial on variable sets](variable-sets.html) for functions that help dealing with the vast number of variables this data.frame can contain. 


### 1.2 Track(ing) data

The tracks data.frame contains information for every cell at a given timepoint. This data.frame only plays a significant role in timelapse experiments. Use `getTracksDf()` to obtain it. 

```{r track-df}

tracks_df <- getTracksDf(object_tracks)

# print first 10 rows
head(tracks_df)

```


### 1.3 Grouping data 

`cypro` distinguishes three types of grouping variables

- well plate variables
- meta variables
- cluster variables 

#### Well Plate data.frame

Well plate variables *well_plate_name*, *well* and *well_image* specify the localisation of cells regarding the experiment design and might be used in case of quality control and removal of batch effects. The respective data.frame can be obtained via `getWellPlateDf()`. 

```{r well-plate-df}

wp_df <- getWellPlateDf(object)

# print first 10 rows
head(wp_df, 10)

```

#### Meta data.frame

Meta variables are grouping variables such as condition and cell line. They will feature a major overlap with those from the the well plate data.frame. However, in case of timelapse experiments that include multiple phases they might differ from phase to phase which is why they are stored separately. Use `getMetaDf()`to obtain the data.frame. 

```{r meta-df}

meta_df <- getMetaDf(object)

# print an example subset of every condition 
dplyr::group_by(meta_df, condition) %>% 
  dplyr::slice_head(n = 3)

```

See the tutorial on how to [add variables]() to the *cto* object to learn how to expand this data.frame. 

#### Cluster data.frame

Cluster variables are the result of applied machine learning techniques such as kmeans- or hierarchical clustering. If none of these have been used the data.frame is going to be empty apart from the identifier variable *cell_id*. See the tutorial on how to [cluster cells](clustering.html) in `cypro`. Obtain the data.frame via `getClusterDf()`.

```{r cluster-df}

cluster_df <- getClusterDf(object)

# print first 10 rows
head(cluster_df, 100)

```


#### Grouping data.frame

All grouping variables together form the grouping data.frame. It can be extracted via `getGroupingDf()` and contains all variables of the three grouping types. 

```{r group-df}

group_df <- getGroupingDf(object)

# print first 10 rows
head(group_df)

```


## 2. Variable data.frame

The variable data.frame focuses on the variables and provides summary statistics. It is stored in the `@vdata`slot. Use `getVariableDf()` to obtain it. 

```{r variable-df}

variable_df <- getVariableDf(object)

# print first 10 rows
head(variable_df)

```


## 3. Set Up data.frame 

Several parts of the experiment design, in particular, the well plate design is stored in data.frames as well. Use `getSetUpDf()` to obtain it. 

```{r set-up-df}

# obtain a vector of all well plate names 
wp_names <- getWellPlateNames(object)

wp_names

set_up_df <- getSetUpDf(object, well_plate_name = wp_names[1])

# print first 10 rows
head(set_up_df)

```


## 4. Variable names

The majority of **celltracers** functions require you to specify some kind of data variables. As exemplified by the stats data.frame above the number of numeric variables can be vast. And since there are several ways to cluster your cells the number of grouping variables might grow in a similar fashion. The tutorial on [variable sets]() explains how you can deal with this multitude of variable with respect to analytics. This chapter explains how you can deal with the multitude of names. 

### 4.1 Functions to extract names

The `get*VariableNames()`-family of functions allows to obtain character vectors of variable names which are the column names of the respective data.frames introduced in chapter 1. Cell data.frames. 

```{r get-var-names, fold.output = T}

stat_vars <- getStatVariableNames(object)

wp_vars <- getWellPlateVariableNames(object)

meta_vars <- getMetaVariableNames(object)

cluster_vars <- getClusterVariableNames(object)

stat_vars

```


### 4.2 Functions to select the right names

You will rarely need all variable names of any kind at once. As exemplified in our tutorial on plotting [descriptive statistics]() at some point you will probably need only shape related variables or only speed related variables. Or you might be only interested in cluster variables of the kmeans method, for instance. This is where the [tidyselect](https://tidyselect.r-lib.org/reference/language.html)-language come in very handy that are implemented in `cypro`. It contains a variety of helper functions but the most important ones are: 

- `starts_with()`
- `ends_with()`
- `contains()`
- `matches()`

(Check out a more detailed description on how they work by either following this [link](https://tidyselect.r-lib.org/reference/language.html) or running `?starts_with` in your R console.)

```{r var-name-helpers, fold.output = T}

# obtain only variables that describe the cells area  
area_names <- getStatVariableNames(object, starts_with("AreaShape"))

area_names

```

Tidyselect helpers are easy to combine. With a bit of practice only little typing is necessary to obtain exactly the variable names you need for your analyis step of interest. 

### 4.3 Examples 

```{r var-name-helpers-2, fold.output = T}

# only zernike features 
zernike_vars <- getStatVariableNames(object, contains("Zernike"))

zernike_vars

# only zernike features that derived from shape analysis
area_zernike_vars <- getStatVariableNames(object, starts_with("AreaShape") & contains("Zernike")) 

area_zernike_vars


# only cluster variables with k = 4
k_4_cluster <- getClusterVariableNames(object, contains("k_4"))

k_4_cluster

# only cluster variables with k = 4 (without hierarchical algorithm)
k_4_cluster2 <- getClusterVariableNames(object, contains("k_4") & -starts_with("hcl"))

k_4_cluster2

```

## 5. Group names

Grouping variables contain information on how to group cells encoded in the group names. In several cases you might want to specify specific groups. To obtain the respective names make use of `getGroupNames()` or its wrapper `getConditions()`, `getCellLines()`.

```{r group-names}

# two ways to obtain condition names
conditions_1 <- getGroupNames(object, grouping_variable = "condition")

conditions_2 <- getConditions(object)

conditions_1

conditions_2

```

The use of `getGroupNames()` to obtain cluster names becomes useful once you have [renamed]() clusters as they are initially encoded in numbers. The tidyselect helpers introduced in chapter 4. Variable names can be used within `getGroupNames()`as well. 

```{r cluster-names}

# all cluster names
hcl5_all <- getGroupNames(object, grouping_variable = "hcl_euclidean_complete_k_5_(intensity)")

hcl5_all

# medium cluster names
hcl5_medium <- getGroupNames(object, grouping_variable = "hcl_euclidean_complete_k_5_(intensity)", contains("medium"))

hcl5_medium

```



